<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Learn | Page Replacement - OS Platform</title>
  <style>
    :root{
      --bg:#000;--bg-2:#0a0a0a;--panel:#111;--panel-2:#131313;--line:#222;
      --text:#fff;--muted:#b9c2cc;--accent:#00bfff;--btn:#0078ff;--btn-hover:#005ec9;
      --ok:#0ecb81;--warn:#ffcc00;--bad:#ff5c5c;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Arial,system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text)}

    /* header */
    header{position:sticky;top:0;z-index:20;display:flex;justify-content:space-between;align-items:center;padding:20px 60px;background:var(--bg-2);border-bottom:1px solid var(--line)}
    .logo{font-size:1.4em;font-weight:700;color:var(--accent)}
    nav{display:flex;align-items:center;gap:150px}
    .dropdown{position:relative;display:inline-block;padding:6px 0;cursor:pointer}
    .dropdown::after{content:" ⌄";display:inline-block;font-size:.8em;color:#ccc;transition:transform .25s ease,color .25s ease}
    .dropdown:hover::after{transform:rotate(180deg);color:var(--accent)}
    .dropdown-content{display:none;position:absolute;background:#111;min-width:180px;box-shadow:0 8px 16px rgba(0,0,0,.3);z-index:10}
    .dropdown-content a{color:#fff;padding:10px 14px;text-decoration:none;display:block}
    .dropdown-content a:hover{background:#333}
    .dropdown:hover .dropdown-content{display:block}
    .actions{display:flex;align-items:center;gap:20px}
    .login-btn{background:var(--btn);color:#fff;border:none;padding:8px 16px;border-radius:20px;cursor:pointer;font-weight:700}
    .login-btn:hover{background:var(--btn-hover)}
    .profile-btn{background:transparent;border:none;padding:0;cursor:pointer;line-height:0;border-radius:999px;outline:none}
    .profile-btn svg{width:36px;height:36px;background:#fff;border-radius:999px;padding:4px}
    .profile-btn:hover svg{box-shadow:0 0 0 3px rgba(0,191,255,.25)}

    /* layout */
    .wrap{max-width:1150px;margin:0 auto;padding:40px 24px 120px;overflow-x:hidden}
    .eyebrow{font-size:.9rem;letter-spacing:.12em;color:var(--muted);text-transform:uppercase}
    h1{margin:.25rem 0 0;font-size:2.2rem;line-height:1.2}
    .lead{margin-top:12px;color:#d7e2ea;line-height:1.7}

    /* markdown-like headings */
    h2.md{font-size:1.6rem;margin:30px 0 12px}
    h2.md::before{content:"\25C6";display:inline-block;margin-right:8px;color:#34b4ff;vertical-align:middle}
    h3.md{font-size:1.15rem;margin:12px 0 8px;color:#9cc7ff}
    h3.md::before{content:"\25C6";display:inline-block;margin-right:6px;color:#34b4ff;vertical-align:middle}

    .hero{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,520px);gap:32px;align-items:center;margin-top:24px}
    .panel{background:radial-gradient(120% 120% at 80% 20%,#003366 0%,#000 60%);border:1px solid var(--line);border-radius:16px;padding:20px;min-height:260px;display:flex;align-items:center;justify-content:center;width:100%}
    .panel svg{display:block;max-width:100%;height:auto}

    .cards-3{display:grid;grid-template-columns:repeat(3,1fr);gap:16px;margin:16px 0 10px}
    .card{background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);border:1px solid var(--line);border-radius:14px;padding:18px}
    .card h3{margin:0 0 8px;font-size:1.05rem;color:#e6f7ff}
    .card p{margin:0;color:#c8d3dc;font-size:.95rem;line-height:1.6}
    .sub{margin-top:6px;color:#9bb3c7;font-size:.9rem}

    /* 알고리즘 카드 (가로 스크롤) */
    .algos{
      margin-top:12px;
      display:flex;
      flex-direction:row;
      gap:14px;
      overflow-x:auto;
      overflow-y:hidden;
      padding-bottom:10px;
      scroll-behavior:smooth;
      white-space:nowrap;
    }
    .algo{
      flex:0 0 330px;
      white-space:normal;
      background:linear-gradient(180deg,#0e0e0e 0%,#0f0f14 100%);
      border:1px solid var(--line);
      border-radius:14px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    /* 스크롤바 커스터마이징 */
    .algos::-webkit-scrollbar{height:6px}
    .algos::-webkit-scrollbar-track{background:#0b0b0b;border-radius:4px}
    .algos::-webkit-scrollbar-thumb{background:#333;border-radius:4px}
    .algos::-webkit-scrollbar-thumb:hover{background:#555}

    .algo h5{
      margin:0;
      font-size:1rem;
      color:#e6f7ff
    }
    .algo p{
      margin:0;
      color:#c8d3dc;
      font-size:.93rem;
      line-height:1.5
    }
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:.8rem;
      padding:4px 10px;
      line-height:1;
      border-radius:999px;
      border:1px solid var(--line);
      color:#9cc7ff;
      background:#0b1a2a;
      vertical-align:middle
    }
    .cta{margin-top:auto;align-self:flex-start;background:transparent;color:var(--accent);border:1px solid rgba(0,191,255,.35);padding:8px 12px;border-radius:10px;cursor:pointer;transition:all .2s ease}
    .cta:hover{background:rgba(0,191,255,.08);border-color:rgba(0,191,255,.6)}

    hr.sep{border:none;border-top:1px solid var(--line);margin:26px 0;opacity:.6}

    @media (max-width:960px){
      .hero{grid-template-columns:1fr}
      .cards-3{grid-template-columns:1fr}
      .algos{padding-bottom:8px}
    }

    /* ===== Paging SVG 기본 ===== */
    .mem-rail{fill:#0b1a2a;stroke:#1f3b52;stroke-width:2}
    .mem-label{fill:#cfeaff;font-size:12px}
    .page{fill:#00bfff;stroke:#0090ff;stroke-width:1.5}
    .frame{fill:#102437;stroke:#2b5b84;stroke-width:1.5}
    .map{stroke:#6ecbff;stroke-width:2.5;marker-end:url(#arrow)}
    .evict{stroke:#ff7b7b;stroke-width:2.5;stroke-dasharray:6 6;marker-end:url(#arrowRed)}

    /* ===== 심화 개념 섹션 ===== */
    .deep-sub{margin-top:4px;color:#9bb3c7;font-size:.9rem}
    .deep-grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:18px;
      margin-top:16px;
    }
    .deep-card{
      position:relative;
      border-radius:14px;
      border:1px solid var(--line);
      background:radial-gradient(140% 160% at 100% 0%,#12263b 0%,#05070a 60%);
      padding:18px 18px 16px;
      min-height:190px;
    }
    .deep-card h3{
      margin:0 0 8px;
      font-size:1.02rem;
      color:#e6f7ff;
    }
    .deep-card p{
      margin:4px 0;
      color:#c8d3dc;
      font-size:.93rem;
      line-height:1.6;
    }
    .deep-key{font-weight:700;color:#ffffff}
    .deep-illus{
      position:absolute;
      top:14px;
      right:14px;
      opacity:.85;
    }
    .deep-illus svg{
      width:58px;
      height:40px;
      display:block;
    }

    @media (max-width:900px){
      .deep-grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">OS Platform</div>
    <nav>
      <div class="dropdown">
        <span>Learn</span>
        <div class="dropdown-content">
          <a href="/learn-scheduling.html">스케줄링</a>
          <a href="/learn-paging.html">페이지교체</a>
          <a href="/learn-deadlock.html">데드록</a>
        </div>
      </div>
      <div class="dropdown">
        <span>Simulator</span>
        <div class="dropdown-content">
          <a href="/sim-scheduling.html">CPU 스케줄링 시뮬레이터</a>
          <a href="/sim-paging.html">페이지교체 시뮬레이터</a>
          <a href="/sim-deadlock.html">데드록 시뮬레이터</a>
        </div>
      </div>
      <div class="dropdown">
        <span><a href="/compare.html" style="color:#fff;text-decoration:none">Compare</a></span>
      </div>
      <div class="dropdown">
        <span><a href="/graph-paging.html" style="color:#fff;text-decoration:none">Graph</a></span>
      </div>
    </nav>
    <div class="actions"><div id="authArea"></div></div>
  </header>

  <div class="wrap">
    <div class="eyebrow">LEARN / Page Replacement</div>
    <h1>페이지 교체란?</h1>
    <div class="lead">
      운영체제는 한정된 물리 메모리를 여러 프로세스가 나눠 쓰도록 관리합니다.<br>
      그런데 모든 프로세스의 페이지 전체를 한꺼번에 메모리에 둘 수 없을 때, 즉 메모리가 꽉 찬 상태에서
      새로운 페이지를 가져와야 할 때, <br> 공간을 확보하기 위해 <b>기존의 어떤 페이지를 내보내고 새 페이지를 들여오는 과정</b>이 필요합니다.<br>
      이것을 <b>페이지 교체</b>라고 합니다.
    </div>

    <!-- 정의 + 비주얼 -->
    <div class="hero">
      <div>
        <div class="cards-3">
          <div class="card">
            <h3>Page Fault</h3>
            <p><b class="deep-key">"페이지 부재"</b></p>
            <p>프로세스가 접근하려는 페이지가 메모리에 없어 보조 기억장치에서 불러와야 할 때 발생하는 인터럽트.</p>
          </div>
          <div class="card">
            <h3>Locality</h3>
            <p><b class="deep-key">"지역성"</b></p>
            <p>프로그램은 시간적으로 가까운 시점에 같은 데이터나 인접한 데이터를 반복해 접근하는 경향이 있다는 성질.</p>
          </div>
          <div class="card">
            <h3>Victim Page</h3>
            <p><b class="deep-key">"희생 페이지"</b></p>
            <p>메모리가 가득 찬 상태에서 새로운 페이지를 적재하기 위해 교체 대상으로 선택되어 내보내지는 페이지.</p>
          </div>
        </div>
      </div>

      <!-- 메모리–디스크 매핑 그림 -->
      <div class="panel paging-p14">
        <svg viewBox="0 0 940 420" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Main memory and secondary storage mapping">
          <defs>
            <style>
              .label{font:14px Arial, sans-serif; fill:#cfeaff}
              .minor{font:12px Arial, sans-serif; fill:#9bb3c7}
              .memBox{fill:#0b1a2a; stroke:#1f3b52; stroke-width:1.5}
              .frameRect{fill:#101820; stroke:#2b5b84}
              .f-blue{fill:#d9e7fb}
              .f-yellow{fill:#ffe39a}
              .f-orange{fill:#f7c0a4}
              .pageCard{fill:#122737; stroke:#2b5b84}
              .p-blue{fill:#c7dbf6}
              .p-yellow{fill:#ffe39a}
              .p-orange{fill:#f7c0a4}
              .wire{stroke:#ffffff; stroke-width:2; marker-end:url(#arr)}
            </style>
            <marker id="arr" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto">
              <polygon points="0 0, 10 3, 0 6" fill="#ffffff"/>
            </marker>
          </defs>

          <!-- LEFT: Main memory (frames) -->
          <g transform="translate(90,40)">
            <rect class="memBox" x="0" y="0" width="220" height="330" rx="6"/>
            <!-- pf-0 -->
            <g transform="translate(10,10)"><rect class="frameRect" width="200" height="36" rx="4"/></g>
            <!-- pf-1 -->
            <g transform="translate(10,56)"><rect class="frameRect" width="200" height="36" rx="4"/></g>
            <!-- pf-2 (파랑) -->
            <g transform="translate(10,102)"><rect class="frameRect f-blue" width="200" height="36" rx="4"/></g>
            <!-- pf-3 -->
            <g transform="translate(10,148)"><rect class="frameRect" width="200" height="36" rx="4"/></g>
            <!-- pf-4 (노랑) -->
            <g transform="translate(10,194)"><rect class="frameRect f-yellow" width="200" height="36" rx="4"/></g>
            <!-- ... -->
            <g transform="translate(10,240)"><rect class="frameRect" width="200" height="36" rx="4"/></g>
            <!-- pf-h (주황) -->
            <g transform="translate(10,286)"><rect class="frameRect f-orange" width="200" height="36" rx="4"/></g>
          </g>

          <!-- RIGHT: Secondary storage (카드 스택) -->
          <g transform="translate(520,20)">
            <text class="label" x="210" y="365" text-anchor="middle">Secondary storage</text>
            <text class="minor" x="210" y="382" text-anchor="middle">(Swap device)</text>

            <!-- 뒤→앞 카드 -->
            <g transform="translate(240,90)"><rect class="pageCard" x="-40" y="-30" width="120" height="70" rx="4"/></g>
            <g transform="translate(220,110)"><rect x="-40" y="-30" width="120" height="70" rx="4" fill="#f7c0a4" stroke="#2b5b84"/></g>
            <g transform="translate(200,130)"><rect class="pageCard" x="-40" y="-30" width="120" height="70" rx="4"/></g>
            <g transform="translate(180,150)"><rect x="-40" y="-30" width="120" height="70" rx="4" class="p-yellow" stroke="#b79b32"/></g>
            <g transform="translate(160,170)"><rect x="-40" y="-30" width="120" height="70" rx="4" class="p-blue" stroke="#5c7db1"/></g>
          </g>

          <!-- 카드 왼쪽 중앙 점 -->
          <circle cx="640" cy="190" r="5" fill="#ffffff" stroke="#ffffff" stroke-width="1"/>
          <circle cx="660" cy="170" r="5" fill="#ffffff" stroke="#ffffff" stroke-width="1"/>
          <circle cx="700" cy="130" r="5" fill="#ffffff" stroke="#ffffff" stroke-width="1"/>

          <!-- 파랑 → pf-2(y=160) -->
          <line class="wire" x1="640" y1="190" x2="300" y2="160"/>
          <!-- 노랑 → pf-4(y=252) -->
          <line class="wire" x1="660" y1="170" x2="300" y2="252"/>
          <!-- 주황 → 하단 주황(y=344) -->
          <line class="wire" x1="700" y1="130" x2="300" y2="344"/>

          <!-- 캡션 -->
          <text class="minor" x="94" y="388" text-anchor="middle">Main Memory</text>
        </svg>
      </div>
    </div>

    <hr class="sep" />

    <!-- 알고리즘 4종 -->
    <h2 class="md">페이지 교체 알고리즘</h2>
    <div class="sub">메모리가 가득 찼을 때, 새 페이지를 불러오기 위해 어떤 페이지를 내보낼지 결정하는 규칙입니다.</div>

    <div class="algos">
      <div class="algo">
        <h3 class="md">FIFO</h3><span class="badge">First In First Out</span>
        <p><b class="deep-key">가장 먼저 들어온 페이지를 먼저 내보내는</b> 단순한 방식.</p>
        <p>구현이 매우 간단하지만, 초기에 자주 쓰이는 페이지가 먼저 교체되어 <b>긴 꼬리 대기</b>가 생길 수 있습니다.</p>
        <p>프레임 수를 늘려도 오히려 Page Fault가 증가하는 <b>Belady의 모순 현상</b>이 대표적으로 나타납니다.</p>
        <button class="cta" onclick="goSim('fifo')">시뮬레이터에서 확인 →</button>
      </div>
      <div class="algo">
        <h3 class="md">OPT</h3><span class="badge">Optimal</span>
        <p><b class="deep-key">앞으로 가장 오랫동안 사용되지 않을 페이지</b>를 제거하는 이상적인 알고리즘.</p>
        <p>Page Fault 수가 이론적으로 최소이지만, <b>미래 참조 정보를 전부 알아야</b> 하므로 실제 시스템에서는 구현할 수 없습니다.</p>
        <p>실제 알고리즘들의 성능을 비교할 때 사용하는 <b>이론적 하한선</b> 역할을 합니다.</p>
        <button class="cta" onclick="goSim('opt')">시뮬레이터에서 확인 →</button>
      </div>
      <div class="algo">
        <h3 class="md">LRU</h3><span class="badge">Least Recently Used</span>
        <p><b class="deep-key">가장 오랫동안 사용되지 않은 페이지</b>를 교체하는 방식으로, 시간적 지역성에 기반합니다.</p>
        <p>최근에 접근된 페이지는 곧 다시 사용될 가능성이 높다고 보고, <b>오래 안 쓴 페이지부터 제거</b>합니다.</p>
        <p>OPT에 가깝지만, 참조 시점을 추적해야 해서 <b>하드웨어·소프트웨어 오버헤드</b>가 생깁니다.</p>
        <button class="cta" onclick="goSim('lru')">시뮬레이터에서 확인 →</button>
      </div>
      <div class="algo">
        <h3 class="md">LFU</h3><span class="badge">Least Frequently Used</span>
        <p><b class="deep-key">참조 횟수가 가장 적은 페이지</b>를 내보내는 방식입니다.</p>
        <p>짧은 구간이 아니라 <b>장기적인 접근 빈도</b>를 반영한다는 장점이 있지만,</p>
        <p>방금 적재된 페이지가 금방 교체되거나, 구현이 복잡해 <b>오버헤드가 커질 수 있다</b>는 단점이 있습니다.</p>
        <button class="cta" onclick="goSim('lfu')">시뮬레이터에서 확인 →</button>
      </div>
      <div class="algo">
        <h3 class="md">NUR / Clock</h3><span class="badge">Not Used Recently</span>
        <p>페이지마다 <b class="deep-key">참조 비트·변형 비트</b>를 두고, <b>최근에 안 쓰인 페이지</b>를 우선 교체하는 방식입니다.</p>
        <p>정확한 LRU는 아니지만, 간단한 비트 정보만으로 <b>근사 LRU</b>를 구현할 수 있어 많이 사용됩니다.</p>
        <p>오버헤드는 적지만, 비트 초기화 주기·스캔 전략에 따라 성능이 달라집니다.</p>
        <button class="cta" onclick="goSim('lfu')">시뮬레이터에서 확인 →</button>
      </div>
    </div>

    <hr class="sep" />

    <!-- 참고할 심화 개념 -->
    <h2 class="md">참고할 심화 개념</h2>
    <div class="deep-sub">
      페이지 교체 알고리즘의 원리를 더 선명하게 만드는 보조적인 심화 개념
    </div>

    <div class="deep-grid">
      <!-- (1) Belady -->
      <div class="deep-card">
        <div class="deep-illus">
          <!-- 프레임 수가 늘어도 Fault가 늘어나는 막대그래프 느낌 -->
          <svg viewBox="0 0 72 40">
            <rect x="6"  y="20" width="10" height="16" fill="#1f3b5c"/>
            <rect x="24" y="10" width="10" height="26" fill="#1f3b5c"/>
            <rect x="42" y="6"  width="10" height="30" fill="#ff7b7b"/>
            <polyline points="5,32 23,26 41,18 59,12" fill="none" stroke="#ffb3b3" stroke-width="1.5"/>
          </svg>
        </div>
        <h3>(1) Belady’s Anomaly (Belady의 모순 현상)</h3>
        <p><b class="deep-key">Belady의 모순</b>은 교체 알고리즘이 <b class="deep-key">Stack Property</b>를 위반했을 때,
          <b class="deep-key">프레임을 늘렸는데도 Page Fault가 오히려 증가하는 수학적 결과</b>가 나타나는 현상입니다.</p>
        <p>Stack Property란, <b>n개의 프레임으로 유지되는 페이지 집합이 항상 n+1개의 프레임 집합의 부분집합</b>이어야 한다는 성질입니다.</p>
        <p>FIFO처럼 <b>“최근 사용 이력”을 고려하지 않는 알고리즘</b>은 이 속성을 보장하지 못해,
          프레임 확장이 오히려 불리하게 작용할 수 있습니다. 즉, <b class="deep-key">교체 기준의 일관성이 깨질 때 나타나는 구조적 현상</b>입니다.</p>
      </div>

      <!-- (2) LRU vs OPT -->
      <div class="deep-card">
        <div class="deep-illus">
          <!-- OPT와 LRU가 비슷하게 가는 곡선 -->
          <svg viewBox="0 0 72 40">
            <polyline points="4,34 20,24 36,18 52,14 68,12" fill="none" stroke="#64c8ff" stroke-width="1.5"/>
            <polyline points="4,32 20,23 36,17 52,13 68,11" fill="none" stroke="#00ffcc" stroke-width="1.5" stroke-dasharray="4 3"/>
            <line x1="8" y1="6" x2="8" y2="34" stroke="#555" stroke-width="1"/>
            <line x1="8" y1="34" x2="68" y2="34" stroke="#555" stroke-width="1"/>
          </svg>
        </div>
        <h3>(2) LRU vs OPT – 시간적 지역성과 통계적 한계</h3>
        <p><b class="deep-key">OPT</b>는 <b>가장 나중에 다시 쓰일 페이지</b>를 교체하여 이론적으로 <b>최소 Page Fault</b>를 보장합니다.</p>
        <p>반면 <b class="deep-key">LRU</b>는 과거 참조 패턴을 기반으로 OPT의 결과를 <b>통계적으로 근사</b>합니다.
          핵심은 <b class="deep-key">시간적 지역성</b>입니다. 최근에 접근한 페이지일수록 다음 접근 확률이 높다는
          <b>Markov적 의존 구조</b>를 가정합니다.</p>
        <p>현대 워크로드는 이 가정이 잘 맞는 경우가 많아 LRU가 <b>OPT와 거의 동등한 성능</b>을 내지만,
          지역성이 약한 <b>랜덤 접근 패턴</b>에선 LRU가 급격히 비효율적이 될 수 있습니다.</p>
      </div>

      <!-- (3) Reference & Dirty Bit -->
      <div class="deep-card">
        <div class="deep-illus">
          <!-- R/D 비트 두 개와 비용 레벨 -->
          <svg viewBox="0 0 72 40">
            <rect x="8" y="8" width="18" height="10" fill="#1f3b5c" stroke="#4ea3ff"/>
            <text x="17" y="16" font-size="8" fill="#cfeaff" text-anchor="middle">R</text>
            <rect x="8" y="22" width="18" height="10" fill="#2b3c20" stroke="#8be27c"/>
            <text x="17" y="30" font-size="8" fill="#e5ffe5" text-anchor="middle">D</text>
            <rect x="36" y="10" width="26" height="6" fill="#355c7d"/>
            <rect x="36" y="18" width="18" height="6" fill="#4ecdc4"/>
            <rect x="36" y="26" width="10" height="6" fill="#ff6b6b"/>
          </svg>
        </div>
        <h3>(3) 참조 비트와 변형 비트 (Reference Bit & Dirty Bit)</h3>
        <p><b class="deep-key">참조 비트(R)</b>와 <b class="deep-key">변형 비트(D)</b>는 단순한 상태 표시기가 아니라,
          운영체제가 페이지의 <b class="deep-key">‘생애 주기’를 추적하는 최소 단서</b>입니다.</p>
        <p>R 비트는 페이지의 <b class="deep-key">활성도</b>를, D 비트는 <b class="deep-key">디스크 쓰기 비용</b>을 의미합니다.
          현대 OS는 두 비트를 조합해 <b>활성/비활성 리스트</b>를 유지하고, 2Q·Clock-Pro 같은 고급 정책을 구현합니다.</p>
        <p>결국 교체는 “가장 오래된 것”을 버리는 문제가 아니라,
          <b>최근에 덜 쓰였고(D=0일수록 좋음), 수정 비용이 덜 드는 페이지</b>를 고르는
          <b class="deep-key">다차원 비용 최소화 문제</b>로 바뀝니다.</p>
      </div>

      <!-- (4) OPT 구현 불가능성 -->
      <div class="deep-card">
        <div class="deep-illus">
          <!-- 수정된 결정 나무 + ? -->
          <svg viewBox="0 0 72 40">
            <circle cx="20" cy="16" r="9" fill="none" stroke="#4ea3ff" stroke-width="1.5"/>
            <path d="M16 14 Q20 8 24 14" fill="none" stroke="#4ea3ff" stroke-width="1"/>
            <circle cx="20" cy="20" r="1.2" fill="#4ea3ff"/>
            <path d="M34 10 L58 30" stroke="#ff7b7b" stroke-width="2"/>
            <path d="M34 30 L58 10" stroke="#ff7b7b" stroke-width="2"/>
          </svg>
        </div>
        <h3>(4) OPT의 구현 불가능성 – 이론적 한계로서의 OPT</h3>
        <p>OPT는 <b class="deep-key">미래 참조 시퀀스를 전부 알고 있다</b>는 가정 위에서만 동작하기 때문에,
          실시간 운영체제에서는 <b class="deep-key">구현 불가능한 이상적인 모델</b>입니다.</p>
        <p>단순히 “미래를 모르기 때문”만이 아니라, 프로세스 입력·스케줄링 순서·입출력 지연 등
          외부 요인으로 인해 <b>메모리 접근 순서 자체가 비결정적</b>이기 때문입니다.</p>
        <p>실제 OS는 OPT를 <b>기대값 관점에서 근사</b>해야 하고,
          그 결과로 LRU, LFU, ARC, Clock-Pro 같은 <b class="deep-key">확률적 대안</b>이 등장합니다.
          따라서 OPT는 <b class="deep-key">교체 알고리즘의 이론적 한계선</b>을 제시하고,
          현실의 모든 정책은 그 한계를 <b>얼마나 잘 따라가는지</b>로 비교할 수 있습니다.</p>
      </div>
    </div>


  </div>

  <script>
    // 로그인/프로필 버튼
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('authArea');
      if (!container) return;
      const user = sessionStorage.getItem('user');
      container.innerHTML = (user && user.trim() !== '')
        ? `<button class="profile-btn" aria-label="My Page" title="My Page" onclick="location.href='mypage.html'">
            <svg viewBox="0 0 24 24" fill="black" xmlns="http://www.w3.org/2000/svg">
              <circle cx="12" cy="8" r="4"></circle>
              <path d="M4 20c0-4 4-6 8-6s8 2 8 6"></path>
            </svg>
           </button>`
        : `<button class="login-btn" onclick="location.href='login.html'">Login</button>`;
    });

    // 시뮬레이터 이동
    function goSim(type){
      location.href = '/sim-paging.html?algo=' + encodeURIComponent(type);
    }

    // 리액트(3000) → 8080 링크 고정
    (function () {
      if (location.port === '3000') {
        document.querySelectorAll('.dropdown-content a').forEach(a => {
          const href = a.getAttribute('href');
          if (href && href.startsWith('/')) {
            a.addEventListener('click', function(e){
              e.preventDefault();
              window.location.assign('http://localhost:8080' + href);
            });
          }
        });
      }
    })();
  </script>
</body>
</html>
